{"componentChunkName":"component---src-templates-post-template-tsx","path":"/230314/sqld5/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>01. 옵티마이저와 실행계획</h2>\n<ol>\n<li>옵티마이저: SQL문에 대한 최적의 실행방법을 결정하여 실행 계획 도출, SQL문에 대한 파싱 후 실행된다, 내비게이션\n<ul>\n<li>SQL문 실행 순서\n<ol>\n<li>파싱(Parsing): SQL 문법 검사 및 구문 분석 작업</li>\n<li>실행(Execution): 옵티마이저의 실행 계획에 따라</li>\n<li>인출(Fetch): 데이터를 읽어 전송</li>\n</ol>\n</li>\n<li>옵티마이저 엔진\n<ul>\n<li>질의 변환기(Query Transformer): 작성된 SQL문을 처리하기 용이한 형태로 변환하는 모듈</li>\n<li>비용 예측기(Estimator): 생성된 계획의 비용을 예측하는 모듈</li>\n<li>대안계획 생성기(Plan Generator): 동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈, 1) 연산 적용 순서 2) 연산 방법 3) 조인 순서의 변경을 통해 대안 계획 생성</li>\n</ul>\n</li>\n<li>종류\n<ul>\n<li>규칙기반 옵티마이저: 우선순위 규칙에 따라 실행계획 생성, 인덱스가 있으면 반드시 인덱스 사용</li>\n<li>비용기반 옵티마이저: 처리 비용이 가장 적은 실행계획 선택, 데이터 딕셔너리(Data Dictionary)의 통계정보나 DBMS의 차이로 같은 쿼리도 다른 실행계획이 생성될 수 있다, 실행계획의 예측 및 제어가 어렵다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SQL 처리 흐름도: SQL문의 처리절차를 시각적으로 표현한 도표</li>\n<li>실행계획: 1) 객체 2) 조인 방법 및 순서 3) 엑세스 패턴 등의 정보 출력\n<ul>\n<li>DESC PLAN_TABLE; : 실행 계획 확인</li>\n<li>해독 순서: ←로 찾다가 2줄 이상의 동일 레벨을 만나면 ↓로 해독</li>\n</ul>\n</li>\n</ol>\n<h2>02. 인덱스 기본</h2>\n<ol>\n<li>인덱스: 검색 조건에 부합하는 데이터를 효과적으로 검색할 수 있도록 돕는 기능, 인덱스키로 정렬되어 있어 조회 속도가 빠름, DML 작업 효율은 저하한다</li>\n</ol>\n<ul>\n<li>트리기반 인덱스: DBMS에서 사용하는 가장 일반적인 인덱스, 1) 루트 블록(Root Block) 2) 브랜치 블록(Branch Block) 3) 리프 블록(Leaf Block)으로 구성된다\n<ul>\n<li>포인터(Pointer): 루트 블록과 브랜치 블록의 키 값, 하위 블록 키 값의 범위 정보</li>\n<li>리프 블록은 1) 인덱스키 2) ROWID로 구성된다, Doubly Linked List 형태라서 양방향 탐색 가능\n<ul>\n<li>ROWID: Oracle에서 데이터를 구분할 수 있는 유일한 값, 데이터를 입력하면 자동으로 생성된다, 데이터가 어떤 데이터 파일의 어느 블록에 속해 있는지 알려준다\n<ul>\n<li>오브젝트 번호: 해당 데이터가 속하는 오브젝트 번호, 오브젝트 별로 유일한 값을 가진다</li>\n<li>상대 파일 번호: 테이블스페이스 내 데이터 파일의 순번</li>\n<li>블록 번호: 데이터 파일 내 데이터가 속해 있는 블록의 순번</li>\n<li>데이터 번호: 데이터 블록에 데이터가 저장되어 있는 순번</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>클러스터형 인덱스 (SQL Server): 인덱스의 리프 페이지가 데이터를 포함한다, 리프 페이지의 모든 로우가 인덱스키 칼럼 순서대로 물리적으로 정렬되어 있다</li>\n<li>CREATE INDEX 인덱스명 테이블명 ON 테이블명 (칼럼명, …) : 인덱스 생성</li>\n<li>인덱스키가 변환되면 사용 불가 ex) NVL(인덱스키,값), TO_타입(인덱스키), 인덱스키||값</li>\n</ul>\n<ol start=\"2\">\n<li>인덱스 스캔 효율화: 랜덤 액세스 최소화 (인덱스 스캔 후 추가 정보를 가져오기 위한 랜덤 액세스는 DBMS 성능 부하를 유발한다)\n<ul>\n<li>인덱스 칼럼의 순서는 랜덤 액세스와 무관하다</li>\n</ul>\n</li>\n<li>스캔 방법\n<ul>\n<li>전체 테이블 스캔(Full Table Scan): 테이블의 모든 데이터를 읽으며 데이터 추출, 읽은 블록의 재사용성을 낮다고 판단하여 메모리 버퍼에서 제거한다\n<ol>\n<li>SQL문에 조건이 없거나</li>\n<li>SQL문 조건 관련 인덱스가 없거나</li>\n<li>전체 테이블 스캔을 하도록 강제로 힌트를 지정하거나</li>\n<li>옵티마이저가 유리하다고 판단하는 경우 수행, 많은 데이터를 조회할 때 유리하다</li>\n</ol>\n</li>\n<li>인덱스 스캔(Index Scan): 인덱스를 구성하는 칼럼의 값을 기반으로 데이터 추출, 인덱스를 읽어 ROWID를 찾고 해당 데이터를 찾기 위해 테이블을 읽음, 일반적으로 인덱스 칼럼 순서로 정렬되어 출력된다, 적은 데이터를 조회할 때 유리하다\n<ol>\n<li>랜덤 액세스에 의한 부하가 발생할 수 있고</li>\n<li>중복 스캔 비효율이 발생한다</li>\n</ol>\n<ul>\n<li>인덱스 범위 스캔(Index Range Scan): 특정 범위에 인덱스 스캔 적용\n<ul>\n<li>인덱스 역순 범위 스캔: 리프 블록의 Doubly Linked List 저장 방식을 활용하여 인덱스를 역순으로 스캔, 결과 집합이 내림차순으로 정렬된다</li>\n</ul>\n</li>\n<li>인덱스 유일 스캔(Index Unique Scan): 인덱스키가 중복되지 않을 때 단 한 건의 데이터 추출, 등호 조건으로 조회한다, 검색 속도가 가장 빠르다</li>\n<li>인덱스 전체 스캔(Index Full Scan): 리프 블록을 모두 읽으며 데이터 추출\n<ul>\n<li>인덱스 고속 전체 스캔: 물리적으로 저장된 순서대로 인덱스 리프 블록 스캔</li>\n<li>인덱스 스킵 스캔: 인덱스 선두 칼럼이 조건절에 없어도 활용한다, 상위 블록에서 읽은 칼럼 값 정보를 이용해 조건에 맞는 데이터를 포함할 가능성이 있는 리프 블록만 접근</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IOT(Index-Organized Table): 인덱스키가 붙은 칼럼으로 구성된 테이블, 인덱스가 원래 테이블을 참조하지 않는다, 클러스터형 인덱스와 유사하다</li>\n</ol>\n<h2>03. 조인 수행 원리</h2>\n<ol>\n<li>조인 순서: 항상 두 테이블을 조인한다\n<ul>\n<li>선행 테이블(First Table, Outer Table, Driving Table, Build Input)</li>\n<li>후행 테이블(Second Table, Inner Table, Driven Table, Probe Input): 선행 테이블로부터 입력값을 받아 처리한다, 후행 테이블에 걸리는 조인 조건이 성능에 큰 영향을 미친다</li>\n</ul>\n</li>\n<li>조인 방식: NL 조인 > 소트 머지 조인 > 해시 조인 순서로 발전된다\n<ul>\n<li>NL 조인(Nested Loop Join)\n<ul>\n<li>선행 테이블의 데이터 하나씩 순차적으로 조인 (중첩 반복문과 유사하다)</li>\n<li>선행 테이블 처리 범위가 성능을 결정한다 (~ 해시 조인, ↔ 소트 머지 조인은 순서에 무관)</li>\n<li>랜덤 액세스 위주이므로 대용량 데이터 처리 시 불리 유니크 인덱스를 이용하여 소량 테이블 조인할 때 유리하다</li>\n</ul>\n<h5></h5>\n<ul>\n<li>절차\n<ol>\n<li>선행 테이블에서 조건을 만족하는 행을 찾는다</li>\n<li>후행 테이블에 선행 테이블의 조인키가 존재하는지 확인한다</li>\n<li>후행 테이블 인덱스에 선행 테이블의 조인키가 존재하는지 확인한다</li>\n<li>인덱스에서 추출한 ROWID로 후행 테이블을 엑세스 한다</li>\n</ol>\n</li>\n<li>조인 결과를 하나씩 바로 출력하여 OLTP 환경에 적합하다</li>\n</ul>\n</li>\n<li>소트 머지 조인(Sort Merge Join): 두 테이블을 개별적으로 스캔한 후 조인 (↔ NL 조인은 선행 테이블을 랜덤 액세스 방식으로 조회하며 조인), 대용량 데이터 처리 시 디스크에서 정렬이 진행되므로 성능상 불리, 인덱스 유무가 성능에 큰 영향을 주진 않는다 (↔ NL 조인은 인덱스 구성에 크게 영향을 받는다)</li>\n<li>해시 조인(Hash Join)\n<ul>\n<li>조인 칼럼을 기준으로 동일한 해시 값을 갖는 데이터의 실제 값을 비교하며 조인, 두 테이블의 데이터 차이가 클 때 유리</li>\n<li>1)NL 조인의 랜덤 액세스와 2)소트 머지 조인의 정렬 작업 부담 해결, 등가 조인에서만 사용할 수 있다, 해시 메모리에서 해시 테이블을 생성하므로 선행 테이블이 작을 때 유리, 테이블이 커서 소트 부하가 심할 때 유리하다</li>\n<li>OLAP 환경에 적합하다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>","frontmatter":{"title":"[Sqld]5장.SQL 최적화 기본 원리","summary":"SQL 최적화 기본 원리","date":"2023.03.14.","categories":["Sqld"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkElEQVR42mP4TwFgoL7mf//+/YWB///AiOY2g6z6/3/JkiX9/X01NdWz5y74eabz/72VYPf8JaD5z58/////b2xstLKysrCwCIuMeb/M9/+hon8gg/8Q0PzvH0jZmTNnNmzYMGXKlBWr1ry9sPT/2zP/wHK0D+0/f/78/PnzFxj8+/Pz/7/fJIf2Pwx3UtPZAH9rfDXOT8LlAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/1eb5e8dd6c983abf05eeb3169edfb996/f5e84/sqld5.png","srcSet":"/static/1eb5e8dd6c983abf05eeb3169edfb996/d0a15/sqld5.png 240w,\n/static/1eb5e8dd6c983abf05eeb3169edfb996/c6b60/sqld5.png 480w,\n/static/1eb5e8dd6c983abf05eeb3169edfb996/f5e84/sqld5.png 960w","sizes":"(min-width: 960px) 960px, 100vw"},"sources":[{"srcSet":"/static/1eb5e8dd6c983abf05eeb3169edfb996/4a319/sqld5.webp 240w,\n/static/1eb5e8dd6c983abf05eeb3169edfb996/0df1a/sqld5.webp 480w,\n/static/1eb5e8dd6c983abf05eeb3169edfb996/eeb31/sqld5.webp 960w","type":"image/webp","sizes":"(min-width: 960px) 960px, 100vw"}]},"width":960,"height":540}},"publicURL":"/static/1eb5e8dd6c983abf05eeb3169edfb996/sqld5.png"}}}}]}},"pageContext":{"slug":"/230314/sqld5/"}},"staticQueryHashes":[],"slicesMap":{}}