---
date: '2023-04-18'
title: '[정처기 실기]1-7.객체지향 구현'
categories: ['정처기 실기']
summary: 'Chapter07.객체지향 구현'
thumbnail: './Engineer_Information_Processing.png'
---
# Chapter07.객체 지향 구현
## Section01.객체지향 설계
1. 객체지향(OOP, Object Oriented Programming)
   1) 객체지향 개념
      * 현실 세계의 유형, 무형의 모든 대상을 객체(Object)로 나누고, 객체의 행동(Method)과 고유한 값(Attribute)을 정의하여 설꼐하는 방법
      * 객체를 만들고 조작하며 객체끼리 관계를 맺음으로써 다수의 객체가 함께 수행될 수 있게 한다.
   2) 객체지향 구성요소
      1) 클래스(Class)
         * 유사한 종류의 유형/무형의 존재를 속성과 연산을 정의해서 만든 툴
         * 다른 클래스와 독립적으로 디자인한다.
         * 데이터를 추상화하는 단위
      2) 객체(Object)
         * 클래스의 인스턴스
         * 객체는 자신 고유의 속성을 가지며, 클래스에서 정의한 연산을 수행
         * 객체의 연산은 클래스에 정의된 연산을 공유함으로써 메모리를 경제적으로 사용
      3) 속성(Attribute)
         * 객체들이 가지고 있는 고유한 데이터를 단위별로 정의한 것
         * 성질, 분류, 수량, 현재 상태 등에 대해 표현한 값
      4) 메서드(Method)
         * 특정한 작업을 수행하기 위한 명령문의 집합
         * 객체가 가지고 있는 속성들을 변경할 수 있는 하나의 연산
      5) 메시지(Message)
         * 객체에게 어던 행위를 하도록 지시
         * 객체의 메서드를 호출함으로써 객체 간의 상호작용을 할 수 있도록 한다.
   3) 객체지향언어의 특징
      1) 캡슐화(Encapsulation)
         * 데이터(Attribute)와 데이터를 처리하는 행동(Method)을 하나로 묶은 것
         * 캡슐화된 객체의 세부내용은 외부에 은폐(정보은닉)되어 오류의 파급 효과가 적다.
         * 캡슐화된 객체들은 재사용이 용이
         * 객체들 간의 메시지를 주고받을 때, 해당 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해지고, 결합도가 낮아진다.
      2) 정보은닉(Information Hiding)
         * 캡슐화의 가장 중요한 개념
         * 다른 객체에게 자신의 데이터를 숨기고, 자신이 정의한 행동만을 통하여 접근을 허용
      3) 상속(Inheritance)
         * 상위클래스(부모클래스)의 모든 데이터와 행동을 하위 클래스가 물려받는 것
         * 상속을 이용하면 하위 클래스는 상위 클래스의 데이터와 행동을 자신의 클래스에 다시 정의하지 않아도 된다.
         * 하위 클래스는 상위 클래스에서 상속받은 요소 외에 새로운 데이터와 행동을 추가하여 사용할 수 있다.
         * 상위클래스의 요소들을 사용할 수 있기 때문에, 소프트웨어 재사용을 증대시키는 중요한 개념
      4) 다형성(Polymorphism)
         * 하나의 메시지에 대해 각 객체가 가지고 있는 여러 가지 방법으로 응답할 수 있는 개념
         * 객체에서 동일한 메서드명을 인자값의 유형이나 개수만 다르게 하는 오버로딩이 존재
         * 객체에서 상속받은 메서드를 재정의하는 오버라이딩이 존재
      5) 추상화(Abstraction)
         * 어떤 실체로부터 공통적인 부분들만 모아 놓은 것
         * 객체의 성질을 분해하고, 공통된 성질을 추출하여 슈퍼 클래스를 설정한다.
   4) 객체지향 설계원칙(SOLID)
      1) 단일 책임 원칙(SRP, Single Responsibility Principle)
         * 한 클래스는 하나의 책임만을 가져야한다.
      2) 개방 폐쇄 원칙(OCP, Open-Closed Principle)
         * 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
         * 기존의 코드를 변경하지 않으면서(Closed) 기능을 추가할 수 있도록(Open) 설계
      3) 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
         * 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
         * 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 작동해야 한다.
      4) 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
         * 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
         * 자신이 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 된다.
      5) 의존성 역전 원칙(DIP, Dependency Inversion Principle)
         * 의존 관계를 맺을 때 자주 변화하는 것보다, 변화가 거의 없는 것에 의존해야 한다.
         * 구체적인 클래스보다 인터페이스나 추상 클래스와 의존 관계를 맺어야 한다.
2. 디자인패턴
   1) 디자인 패턴(Design Pattern) 개념
      * 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들에 대해 재사용할 수 있도록 만들어놓은 패턴들의 모음
      * 이미 만들어져서 잘 되는 것을 활용하여 재사용함으로써 프로그램 최적화에 도움을 준다.
      * 효율적인 코드를 만들기 위한 방법론
   2) 디자인 패턴 구조
      1) 패턴의 이름과 유형
         * 패턴을 부를 때 사용하는 이름과 패턴의 유형
      2) 문제 및 배경
         * 패턴이 사용되는 분야 또는 배경, 해결하는 문제
      3) 솔루션
         * 패턴을 이루는 요소들, 관계, 협동 과정
      4) 결과
         * 패턴을 사용하면 얻게 되는 이점과 영향
      5) 사례
         * 간단한 적용사례
      6) 샘플 코드
         * 패턴이 적용된 원시코드
   3) GoF 디자인 패턴
      * GoF(Gang of Four)의 디자인 패턴
        - 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)에 의해 개발 영역에서 디자인 패턴을 구체화하고 체계화시킴
        - 23가지의 디자인 패턴을 정리
        - 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류
      * GoF 디자인 패턴 분류
        * | 생성 패턴 | 객체 생성과 관련한 패턴<br/>객체 생성에 있어서 프로그램 구조에 영향을 크게 주지 않는 유연성 제공 |
          |:-----:|:----------------------------------------------------------|
          | 구조 패턴 | 클래스나 객체를 조합해서 더 큰 구조를 만드는 패턴                              |
          | 행위 패턴 | 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴                          |
      
        - | 생성(Creational) 패턴                                                           | 구조(Structural) 패턴                                                                 | 행위(Behavioral) 패턴                                                                                                                                              |
          |-----------------------------------------------------------------------------|-----------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
          | Abstract Factory<br/>Builder<br/>Factory Method<br/>Prototype<br/>Singleton | Adapter<br/>Bridge<br/>Composite<br/>Decorator<br/>Facade<br/>Flyweight<br/>Proxy | Chanin of Responsibility<br/>Command<br/>Interpreter<br/>Iterator<br/>Mediator<br/>Memento<br/>Observer<br/>State<br/>Strategy<br/>Template Method<br/>Visitor |
   4) 디자인 패턴 종류
      1) 생성 패턴
         * 객체의 생성과 관련된 패턴
         * 객체의 인스턴스 생성을 추상화하는 방법
         * 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 한다.
           * |              종류               | 설명                                                                                                                                |
             |:-----------------------------:|:----------------------------------------------------------------------------------------------------------------------------------|
             | 추상 팩토리<br/>(Abstract Factory) | 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴                                                                       |
             |       빌더<br/>(Builder)        | 복합 객체의 생성과 표현을 분리하여 동일한 생성 절차에서도 다른 표현 결과를 만들어 낼 수 있음<br/>```new User.Builder(10).name("이름").password("1234").age(43).build();``` |
             | 팩토리 메소드<br/>(Factory Method)  | 객체 생성을 서브클래스로 위임하여 캡슐화 함<br/>Virtual-Constructor 패턴이라고도 함                                                                         |
             |     프로토타입<br/>(Prototype)     | 원본 객체를 복사함으로써 객체를 생성함<br/>java의 clone()을 이용하여 생성하고자 하는 객체에 clone에 대한 Override를 해준다.                                               |
             |      싱글톤<br/>(Singleton)      | 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있도록 함                                                                                          |
         * 싱글톤 예시
           ```java
           public class CarClass{
                //자신의 객체를 바로 생성
                private static CarClass car = new CarClass();
                //생성자가 private이기 때문에 외부에서 접근 불가
                private CarClass(){}
                //getInstance 메서드를 이용해서 해당 인스턴스를 사용
                public static CarClass getInstance(){
                    return car;
                }    
           }
           ```
      2) 구조 패턴
         * 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴
         * 상속을 통해 클래스나 인터페이스를 합성하는 방법을 정의
           * |           종류           | 설명                                                                                                         |
             |:----------------------:|:-----------------------------------------------------------------------------------------------------------|
             |   어댑터<br/>(Adapter)    | 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함                                                             |
             |    브리지<br/>(Bridge)    | 구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있게 함                                                                        |
             |  컴포지트<br/>(Composite)  | 객체들의 관계를 트리 구조로 구성하여 복합 객체와 단일 객체를 구분없이 다룸<br/>하나 이상의 유사한 객체를 구성으로 설계된 객체로 모두 유사한 기능을 나타낸다.                |
             | 데코레이터<br/>(Decorator)  | 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식                                                                      |
             |    퍼사드<br/>(Facade)    | 서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스(Wrapper) 제공<br/>서브시스템의 가장 앞쪽에 위치하면서 서브시스템에 있는 객체들을 사용할 수 있또록 인터페이스 역할 |
             | 플라이웨이트<br/>(Flyweight) | 크기가 작은 여러 개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메로리를 절약함                                                    |
             |    프록시<br/>(Proxy)     | 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 대리(Surrogate)나 대체글(Placeholder)을 제공                                           |
         * 프리지 예시
           ```java
           interface Shape{
                public void draw();
           }
           class CircleShape implements Shape{
                public void draw(){
                    printf("Circle");
                }    
           }
           class SquareShapeimplements Shape{
                public void draw(){
                    printf("Square");
                }    
           }
           ```
      3) 행위 패턴
         * 클래스나 객체들이 상호작용하는 방법을 정의한 패턴
         * 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하여 결합도를 최소화할 수 있도록 도와준다.
           * |                 종류                  | 설명                                                                                                          |
             |:-----------------------------------:|:------------------------------------------------------------------------------------------------------------|
             | 책임 연쇄<br/>(Chain of Responsibility) | 요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달함                                                |
             |          커맨드<br/>(Command)          | 요청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장함                                                                      |
             |       인터프리터<br/>(Interpreter)       | 특정 언어의 문법 표현을 정의함                                                                                           |
             |         반복자<br/>(Iterator)          | 내부를 노출하지 않고 접근이 잦은 어떤 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공                                                   |
             |         중재자<br/>(Mediator)          | 한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의                                                                      |
             |          메멘토<br/>(Memento)          | 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화                                                                         |
             |         옵저버<br/>(Observer)          | 객체 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함                                                              |
             |           상태<br/>(State)            | 객체 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용                                                                           |
             |          전략<br/>(Strategy)          | 동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하도록 함                                                                      |
             |    템플릿 메소드<br/>(Template Method)    | 상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브클래스로 위임함                                                                  |
             |          방문자<br/>(Visitor)          | 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성함<br/>객체지향 원칙(SOLID) 중 하나인 개방-폐쇄 원칙(OCP, Open-Closed Principle)을 적용하는 방법 |